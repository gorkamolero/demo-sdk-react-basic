// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, {
  useState,
  useCallback,
  createContext,
  useContext,
  useEffect,
} from "react";
import { Item, Section } from "@react-stately/collections";
import { exists, noop, renderChildren } from "./_internal_utils";
export const CollectionContext = createContext({
  registerItem: noop,
  isProxy: false,
});

function CollectionRootProxy(props) {
  return (
    <div
      style={{
        display: "none",
      }}
    >
      <ItemContext.Provider
        value={{
          isSelected: false,
          isFocused: false,
          key: null,
        }}
      >
        {renderChildren(props.children, {})}
      </ItemContext.Provider>
    </div>
  );
}

export function buildCollectionItemProxyWithType(ctor, extra) {
  return (props) => {
    const { registerItem, unregisterItem } = useContext(CollectionContext);
    useEffect(() => {
      const key = exists(props.value) ? props.value : props.key;
      registerItem({
        key,
        props: { ...extra, ...props },
        ctor,
        type: "item",
      });
      return () => unregisterItem(key);
    }, []);
    return null;
  };
}
export const CollectionItemProxy = buildCollectionItemProxyWithType();
export function buildCollectionSectionProxy(ctor) {
  return (props) => {
    const { registerItem, unregisterItem } = useContext(CollectionContext);
    const [sectionChildren, setSectionChildren] = useState({});
    useEffect(() => {
      const key = exists(props.value) ? props.value : props.key;
      registerItem({
        key,
        props,
        ctor,
        type: "section",
        children: sectionChildren,
      });
      return () => unregisterItem(key);
    }, [sectionChildren]);
    const addToSection = useCallback(
      (item) => {
        setSectionChildren((prev) =>
          exists(prev[item.key]) ? prev : { ...prev, [item.key]: item }
        );
      },
      [setSectionChildren]
    );
    const removeFromSection = useCallback(
      (keyToDelete) => {
        setSectionChildren((prev) => {
          return Object.keys(prev)
            .filter((key) => key !== keyToDelete)
            .reduce((obj, key) => {
              return { ...obj, [key]: prev[key] };
            }, {});
        });
      },
      [setSectionChildren]
    );
    return (
      <div
        style={{
          display: "none",
        }}
      >
        <CollectionContext.Provider
          value={{
            registerItem: addToSection,
            unregisterItem: removeFromSection,
            isProxy: true,
          }}
        >
          {renderChildren(props.children, {})}
        </CollectionContext.Provider>
      </div>
    );
  };
}

function renderItems(items, ItemCtor) {
  return Object.values(items).map((item) => {
    const Element = exists(item.ctor) ? item.ctor : ItemCtor;

    if (item.type === "section") {
      return (
        <Section title={<Element {...item.props} />}>
          {renderItems(item.children, ItemCtor)}
        </Section>
      );
    }

    return (
      <Item textValue={item.key} key={item.key}>
        <Element {...item.props} />
      </Item>
    );
  });
}

export function CollectionRoot(props) {
  const [items, setItems] = useState({});
  const { ParentCtor, ItemCtor } = props;
  const registerItem = useCallback(
    (item) => {
      setItems((prev) =>
        exists(prev[item.key]) ? prev : { ...prev, [item.key]: item }
      );
    },
    [setItems]
  );
  const unregisterItem = useCallback(
    (keyToDelete) => {
      setItems((prev) => {
        return Object.keys(prev)
          .filter((key) => key !== keyToDelete)
          .reduce((obj, key) => {
            return { ...obj, [key]: prev[key] };
          }, {});
      });
    },
    [setItems]
  );
  return (
    <>
      <CollectionContext.Provider
        value={{
          registerItem,
          unregisterItem,
          isProxy: true,
        }}
      >
        <CollectionRootProxy {...props} />
      </CollectionContext.Provider>
      <CollectionContext.Provider
        value={{
          isProxy: false,
        }}
      >
        <ParentCtor {...props} items={renderItems(items, ItemCtor)} />
      </CollectionContext.Provider>
    </>
  );
}
export function proxy(ProxyElement, Element) {
  return (props) => {
    const { isProxy } = useContext(CollectionContext);
    return isProxy ? <ProxyElement {...props} /> : <Element {...props} />;
  };
}
export const ItemContext = createContext(null);
