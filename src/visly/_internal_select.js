// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, {
  createContext,
  useContext,
  useRef,
  useState,
  useLayoutEffect,
  useMemo,
  useEffect,
} from "react";
import {
  ListLayout,
  mergeProps,
  HiddenSelect,
  useSelectState,
  useSelect,
  useButton,
  useListBox,
  useOption,
  useFocusRing,
  Virtualizer,
  VirtualizerItem,
  DismissButton,
} from "@visly/core";
import { combineRef, exists, renderChildren } from "./_internal_utils";
import { usePrimitive } from "./_internal_usePrimitive";
import { Popover } from "./builtins/Popover";
import {
  CollectionRoot,
  proxy,
  CollectionItemProxy,
  ItemContext,
} from "./_internal_collection";
import { useFormLabel } from "./_internal_formlabel";
export const SelectContext = createContext({
  triggerProps: {},
  triggerRef: null,
  buttonStyles: {},
  testId: "",
  vislyProps: {},
  menuProps: {},
  state: null,
  layout: null,
  renderInline: false,
  rootClassName: "",
  triggerMeasureRef: null,
});

function SelectButtonImpl(props) {
  const {
    triggerRef,
    triggerMeasureRef,
    vislyProps,
    testId,
    buttonStyles,
    triggerProps,
  } = useContext(SelectContext);

  const _triggerProps = mergeProps(triggerProps, {
    onKeyDown: (e) => {
      if (e.key === "Escape") {
        e.continuePropagation();
      }
    },
  });

  const { buttonProps } = useButton(_triggerProps, triggerRef);
  return (
    <button
      {...mergeProps(buttonProps, vislyProps)}
      data-testid={testId}
      ref={combineRef(
        combineRef(props.measureRef, triggerMeasureRef),
        triggerRef
      )}
      className={props.className}
      style={buttonStyles}
    >
      {props.children}
    </button>
  );
}

function SelectOptionContainerImpl(props) {
  const { state, renderInline } = useContext(SelectContext);
  return state.isOpen || renderInline ? (
    <_SelectOptionContainer {...props} />
  ) : null;
}

function useListBoxLayout(state) {
  const layout = useMemo(
    () =>
      new ListLayout({
        estimatedRowHeight: 0,
        padding: 0,
      }),
    []
  );
  layout.collection = state.collection;
  layout.disabledKeys = state.disabledKeys;
  return layout;
}

function _SelectOptionContainer(props) {
  const {
    menuProps,
    state,
    layout,
    renderInline,
    triggerRef,
    rootClassName,
    gap,
  } = useContext(SelectContext);
  const listboxRef = useRef(null);
  const { listBoxProps } = useListBox(
    {
      ...menuProps,
      autoFocus: true,
      disallowEmptySelection: true,
      "aria-label": exists(state.selectedKey) ? state.selectedKey : "none",
      id: menuProps.id,
      isVirtualized: true,
      keyboardDelegate: layout,
    },
    state,
    listboxRef
  );
  const [buttonWidth, setButtonWidth] = useState(null);
  useLayoutEffect(() => {
    if (exists(triggerRef)) {
      const width = triggerRef.current.offsetWidth;
      setButtonWidth(width);
    }
  }, [triggerRef, state.selectedKey]);

  const renderWrapper = (parent, reusableView) => {
    return (
      <VirtualizerItem
        key={reusableView.key}
        reusableView={reusableView}
        parent={parent}
      />
    );
  };

  if (renderInline) {
    return (
      <ul
        ref={combineRef(listboxRef, props.measureRef)}
        className={props.className}
        style={{
          marginTop: gap,
        }}
      >
        <ItemContext.Provider
          value={{
            isSelected: false,
            isFocused: false,
            key: null,
          }}
        >
          {props.children}
        </ItemContext.Provider>
      </ul>
    );
  }

  return (
    <Popover
      scrollRef={listboxRef}
      triggerRef={triggerRef}
      isOpen={state.isOpen}
      containFocus
      onShouldClose={state.close}
      placement="bottom start"
    >
      <DismissButton onDismiss={() => state.close()} />
      <div key={props.innerKey} className={rootClassName}>
        {exists(props.cssStyles) ? (
          <style
            style={{
              display: "none",
            }}
          >
            {props.cssStyles}
          </style>
        ) : null}

        <Virtualizer
          {...mergeProps(listBoxProps, menuProps)}
          ref={listboxRef}
          layout={layout}
          collection={state.collection}
          sizeToFit="height"
          scrollDirection="vertical"
          renderWrapper={renderWrapper}
          focusedKey={state.selectionManager.focusedKey}
          className={props.className}
          style={{
            marginTop: gap,
            marginBottom: gap,
            overflow: "auto",
            ...(props.useButtonWidth
              ? {
                  width: buttonWidth,
                }
              : {}),
            padding: undefined,
          }}
        >
          {(_type, item) => {
            return <Option key={item.key} item={item} />;
          }}
        </Virtualizer>
      </div>
      <DismissButton onDismiss={() => state.close()} />
    </Popover>
  );
}

function Option({ item }) {
  const { state } = useContext(SelectContext);
  const ref = useRef();
  const isDisabled = state.disabledKeys.has(item.key);
  const isSelected = state.selectionManager.isSelected(item.key);
  const { optionProps } = useOption(
    {
      key: item.key,
      isDisabled,
      isSelected,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      "aria-label": item.key,
      isVirtualized: true,
    },
    state,
    ref
  );
  const { focusProps, isFocusVisible } = useFocusRing();
  return (
    <li {...mergeProps(optionProps, focusProps)} ref={ref}>
      <ItemContext.Provider
        value={{
          isSelected,
          isFocused: isFocusVisible,
          key: item.key,
        }}
      >
        {item.rendered}
      </ItemContext.Provider>
    </li>
  );
}

export function SelectRootImpl(props) {
  const ref = useRef(null);
  const { selected, onSelect, renderInline, items, gap = 10 } = props;
  const { style, testId, values, vislyProps, isDisabled } = usePrimitive({
    ref,
    props,
  });
  const { className, ...other } = vislyProps;
  const { label, registerLabelProps } = useFormLabel();
  const state = useSelectState({
    children: items,
    selectedKey: selected,
    onSelectionChange: onSelect,
    disallowEmptySelection: true,
    shouldFlip: true,
    label,
    isDisabled,
  });
  const layout = useListBoxLayout(state);
  const { triggerProps, menuProps, labelProps } = useSelect(
    {
      children: items,
      selectedKey: selected,
      onSelectionChange: onSelect,
      shouldFlip: true,
      keyboardDelegate: layout,
      label,
    },
    state,
    ref
  );
  useEffect(() => {
    registerLabelProps(labelProps);
  }, []);
  triggerProps.isDisabled = isDisabled;
  return (
    <div
      className={className}
      style={{ ...style, display: renderInline ? "flex" : "contents" }}
    >
      <HiddenSelect
        state={state}
        triggerRef={ref}
        label={label || "Select"}
        name="Select"
      />
      <SelectContext.Provider
        value={{
          buttonStyles: style,
          renderInline,
          triggerProps,
          triggerRef: ref,
          triggerMeasureRef: props.measureRef,
          vislyProps: other,
          testId,
          state,
          layout,
          menuProps,
          rootClassName: className,
          gap,
        }}
      >
        {renderChildren(props.children, values)}
      </SelectContext.Provider>
    </div>
  );
}

function SelectOptionRootImpl(props) {
  const ref = useRef();
  const { isSelected, isFocused } = useContext(ItemContext) || {};
  const { style, testId, innerRef, values, vislyProps } = usePrimitive({
    ignoreFocusHandling: true,
    isFocusVisible: isFocused,
    ref,
    props,
    variants: isSelected
      ? [
          {
            propName: "selected",
          },
        ]
      : [],
  });
  return (
    <div
      key={props.value}
      ref={combineRef(props.measureRef, combineRef(innerRef, ref))}
      data-testid={testId}
      {...vislyProps}
      style={style}
    >
      {renderChildren(props.children, values)}
    </div>
  );
}

const ProxyElements = {
  Button: () => null,
  OptionContainer: (props) => {
    return <>{props.children}</>;
  },
};
export const SelectButton = proxy(ProxyElements.Button, SelectButtonImpl);
export const SelectOptionContainer = proxy(
  ProxyElements.OptionContainer,
  SelectOptionContainerImpl
);
export const SelectOptionRoot = proxy(
  CollectionItemProxy,
  SelectOptionRootImpl
);
export function SelectRoot(props) {
  return (
    <CollectionRoot
      {...props}
      ParentCtor={SelectRootImpl}
      ItemCtor={SelectOptionRootImpl}
    />
  );
}
